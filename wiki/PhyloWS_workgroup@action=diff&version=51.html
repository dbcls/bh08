<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

    <html xmlns="http://www.w3.org/1999/xhtml">
  
  


  

  <head>
    <title>
      PhyloWS_workgroup (diff) – Hackathon
    </title>
        <link rel="search" href="../search.1.html" />
        <link rel="help" href="TracGuide.html" />
        <link rel="up" href="PhyloWS_workgroup@action=history.html" title="Page history" />
        <link rel="next" href="PhyloWS_workgroup@action=diff&amp;version=52.html" title="Version 52" />
        <link rel="start" href="../wiki.1.html" />
        <link rel="stylesheet" href="../chrome/common/css/trac.css" type="text/css" /><link rel="stylesheet" href="../chrome/common/css/wiki.css" type="text/css" /><link rel="stylesheet" href="../chrome/common/css/diff.css" type="text/css" />
        <link rel="prev" href="PhyloWS_workgroup@action=diff&amp;version=50.html" title="Version 50" />
        <link rel="shortcut icon" href="../chrome/common/trac.ico" type="image/x-icon" />
        <link rel="icon" href="../chrome/common/trac.ico" type="image/x-icon" />
      <link type="application/opensearchdescription+xml" rel="search" href="../search/opensearch" title="Search Hackathon" />
    <script type="text/javascript" src="../chrome/common/js/jquery.js"></script><script type="text/javascript" src="../chrome/common/js/trac.js"></script><script type="text/javascript" src="../chrome/common/js/search.js"></script><script type="text/javascript" src="http://hackathon.dbcls.jp/chrome/common/js/diff.js"></script>
    <!--[if lt IE 7]>
    <script type="text/javascript" src="/chrome/common/js/ie_pre7_hacks.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="../chrome/common/css/diff.css" /><meta name="ROBOTS" content="NOINDEX, NOFOLLOW" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <a id="logo" href="../index.html"><img src="../chrome/site/BioHackathon.png" alt="" /></a>
      </div>
      <form id="search" action="../search.1.html" method="get">
        <div>
          <label for="proj-search">Search:</label>
          <input type="text" id="proj-search" name="q" size="18" value="" />
          <input type="submit" value="Search" />
        </div>
      </form>
      <div id="metanav" class="nav">
    <ul>
      <li class="first"><a href="http://hackathon.dbcls.jp/login">Login</a></li><li><a href="TracGuide.html">Help/Guide</a></li><li><a href="../about.html">About Trac</a></li><li class="last"><a href="../prefs.html">Preferences</a></li>
    </ul>
  </div>
    </div>
    <div id="mainnav" class="nav">
    <ul>
      <li class="first active"><a href="../wiki.1.html">Wiki</a></li><li><a href="../timeline.html">Timeline</a></li><li><a href="../milestone/index.html">Roadmap</a></li><li><a href="../browser.html">Browse Source</a></li><li><a href="../report.html">View Tickets</a></li><li class="last"><a href="../search.1.html">Search</a></li>
    </ul>
  </div>
    <div id="main">
      <div id="ctxtnav" class="nav">
        <h2>Context Navigation</h2>
          <ul>
              <li class="first"><span>&larr; <a class="prev" href="PhyloWS_workgroup@action=diff&amp;version=50.html" title="Version 50">Previous Change</a></span></li><li><a href="PhyloWS_workgroup@action=history.html" title="Page history">Wiki History</a></li><li class="last"><span><a class="next" href="PhyloWS_workgroup@action=diff&amp;version=52.html" title="Version 52">Next Change</a> &rarr;</span></li>
          </ul>
        <hr />
      </div>
    <div id="content" class="wiki">
      <h1>Changes
        between
          <a href="PhyloWS_workgroup@version=50.html">Version 50</a> and
        <a href="PhyloWS_workgroup@version=51.html">Version 51</a> of
        <a href="PhyloWS_workgroup@version=51.html">PhyloWS_workgroup</a>
      </h1>
      <form method="post" id="prefs" action="PhyloWS_workgroup@version=51.html"><div><input type="hidden" name="__FORM_TOKEN" value="a95c9f905160fbf18dadd01b" /></div>
        <div>
          <input type="hidden" name="action" value="diff" />
          <input type="hidden" name="version" value="51" />
          <input type="hidden" name="old_version" value="50" />
    <label for="style">View differences</label>
    <select id="style" name="style">
      <option selected="selected" value="inline">inline</option>
      <option value="sidebyside">side by side</option>
    </select>
    <div class="field">
      Show <input type="text" name="contextlines" id="contextlines" size="2" maxlength="3" value="2" />
      <label for="contextlines">lines around each change</label>
    </div>
    <fieldset id="ignore">
      <legend>Ignore:</legend>
      <div class="field">
        <input type="checkbox" id="ignoreblanklines" name="ignoreblanklines" />
        <label for="ignoreblanklines">Blank lines</label>
      </div>
      <div class="field">
        <input type="checkbox" id="ignorecase" name="ignorecase" />
        <label for="ignorecase">Case changes</label>
      </div>
      <div class="field">
        <input type="checkbox" id="ignorewhitespace" name="ignorewhitespace" />
        <label for="ignorewhitespace">White space changes</label>
      </div>
    </fieldset>
    <div class="buttons">
      <input type="submit" name="update" value="Update" />
    </div>
        </div>
      </form>
      <dl id="overview">
        <dt class="property time">Timestamp:</dt>
        <dd class="time">
          2008/02/15 16:37:44 (<a class="timeline" href="../timeline@from=2008-02-15T16%253A37%253A44+0900&amp;precision=second.html" title="2008-02-15T16:37:44+0900 in Timeline">17 years</a> ago)
        </dd>
        <dt class="property author">Author:</dt>
        <dd class="author">
          rvos
        </dd>
        <dt class="property message">Comment:</dt>
        <dd class="message">
          
          <p>
--
</p>

        </dd>
      </dl>
      <div class="diff">
        <div class="legend" id="diff-legend">
          <h3>Legend:</h3>
          <dl>
            <dt class="unmod"></dt><dd>Unmodified</dd>
            <dt class="add"></dt><dd>Added</dd>
            <dt class="rem"></dt><dd>Removed</dd>
            <dt class="mod"></dt><dd>Modified</dd>
          </dl>
        </div>
        <div class="diff">
  <ul class="entries">
      <li class="entry">
        <h2 id="file0">
          <a href="PhyloWS_workgroup@version=51.html">PhyloWS_workgroup</a>
        </h2>
        <table class="inline" summary="Differences" cellspacing="0">
              <colgroup><col class="lineno" /><col class="lineno" /><col class="content" /></colgroup>
              <thead>
                <tr>
                  <th title="Version 50">
                    <a href="PhyloWS_workgroup@version=50.html#L1">
                      v50</a>
                  </th>
                  <th title="Version 51">
                    <a href="PhyloWS_workgroup@version=51.html#L1">
                      v51</a>
                  </th>
                  <th> </th>
                </tr>
              </thead>
            <tbody class="mod">
                      <tr class="first">
                        <th>1</th><th> </th><td class="l"><span>== PhyloWS BioHackathon Report ==</span> </td>
                      </tr>
                      <tr>
                        <th> </th><th>1</th><td class="r"><span>== PhyloWS !BioHackathon Report ==</span> </td>
                      </tr><tr class="last">
                        <th> </th><th>2</th><td class="r"><span>[[PageOutline(1-3)]]</span> </td>
                      </tr>
            </tbody><tbody class="unmod">
                  <tr>
                          <th>2</th><th>3</th><td class="l"><span>At present there is no standard web-service API for phylogenetic data that would allow integration of phylogenetic data and service providers into the programmable web. Hence, current approaches to integrate data and services into workflows are highly specific to the integration platform (CIPRES, Bioperl, Bio::Phylo, Kepler), and nearly unusable in other environments. This work group was formed to remedy this.</span> </td>
                  </tr>
            </tbody><tbody class="mod">
                      <tr class="first">
                        <th>3</th><th> </th><td class="l"><span>=== Brainstorm sessions (Monday) ===</span> </td>
                      </tr><tr>
                        <th>4</th><th> </th><td class="l"><span>&nbsp;* What's our scope for now?</span> </td>
                      </tr><tr>
                        <th>5</th><th> </th><td class="l"><span>&nbsp;* Accumulate use cases</span> </td>
                      </tr><tr>
                        <th>6</th><th> </th><td class="l"><span>&nbsp;* Accumulate requirements</span> </td>
                      </tr><tr>
                        <th>7</th><th> </th><td class="l"><span>&nbsp;* Propose a simple API</span> </td>
                      </tr><tr>
                        <th>8</th><th> </th><td class="l"><span>&nbsp;* Start reference implementations</span> </td>
                      </tr><tr>
                        <th>9</th><th> </th><td class="l"><span>&nbsp;* Have another round of OTU discussions</span> </td>
                      </tr><tr>
                        <th>10</th><th> </th><td class="l"><span>=== Formalizing scope, use cases, requirements (Tuesday) ===</span> </td>
                      </tr><tr>
                        <th>11</th><th> </th><td class="l"><span>&nbsp;* In a [http://hackathon.dbcls.jp/attachment/wiki/PhyloWS_workgroup/P1070128.JPG white board] exercise, we identified plausible input and output data types for phyloinformatic webservices. Plausibility is defined by our being able to imagine [https://www.nescent.org/wg_evoinfo/PhyloWS#Use_Cases use cases] (no time line for implementation implied, the goal here is to come up with interfaces)</span> </td>
                      </tr><tr>
                        <th>12</th><th> </th><td class="l"><span>&nbsp;* For all I/O combinations, imagine a [https://www.nescent.org/wg/evoinfo/index.php?title=PhyloWS#Use_Cases use case], move to NESCent wiki</span> </td>
                      </tr><tr>
                        <th>13</th><th> </th><td class="l"><span>&nbsp;* For each use case, classify [https://www.nescent.org/wg/evoinfo/index.php?title=PhyloWS#PhyloWS_Requirements scope and requirements]</span> </td>
                      </tr>
                      <tr>
                        <th> </th><th>4</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>5</th><td class="r"><span>To begin with, we discussed what our scope for now would be. We accumulated use cases and requirements, proposed a simple API and started reference implementations. In addition, we had discussions over node metadata and the Operational Taxonomic Unit concept.</span> </td>
                      </tr><tr>
                        <th> </th><th>6</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>7</th><td class="r"><span>=== Node metadata ===</span> </td>
                      </tr><tr>
                        <th> </th><th>8</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>9</th><td class="r"><span>We&nbsp; need to be able to associate (typed) data with tree branches - the obvious example are branch lengths - but we usually also have (possibly multiple) support values associated with tree branches.</span> </td>
                      </tr><tr>
                        <th> </th><th>10</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>11</th><td class="r"><span>There is an extensive number of metadata elements one might want to record for nodes in a tree. Beyond the basic gene name, sequence ID, and taxon, metadata range from biogeography (area, lat/long), to host species (for analyses of host/parasite co-evolution), to functional attributes (GO terms, expression, subcellular location). </span> </td>
                      </tr><tr>
                        <th> </th><th>12</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>13</th><td class="r"><span>Some of these attributes may blur the line to actual character data for nodes (whether tips or internal). In fact, the notion of strictly distinguishing between node metadata and node character data may not be tenable or useful in reality; data may be metadata in one situation, and used as correlated character in another situation, and used for tree inference in a third situation.</span> </td>
                      </tr><tr>
                        <th> </th><th>14</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>15</th><td class="r"><span>There are essentially two ways to represent node metadata:</span> </td>
                      </tr><tr>
                        <th> </th><th>16</th><td class="r"><span>&nbsp;* Using a metadata schema (for example, an XML Schema, or a XML document definition, similar to metadata schemas in use in the library sciences such as DC, MARC21, etc).</span> </td>
                      </tr><tr>
                        <th> </th><th>17</th><td class="r"><span>&nbsp; * Pros: provides a clear expectation for clients as to what metadata to expect, and the meaning of those elements can be (hard-) coded into applications.</span> </td>
                      </tr><tr>
                        <th> </th><th>18</th><td class="r"><span>&nbsp; * Cons: limited to whatever the metadata schema allows for, and any new metadata elements deemed useful by emerging research cannot be readily expressed (and rectifying that requires a metadata schema update, which in turn affects client applications rather directly). In addition, the meaning of metadata elements cannot be dynamically inferred or stated; it is implicit from the XML DTD or Schema definition.</span> </td>
                      </tr><tr>
                        <th> </th><th>19</th><td class="r"><span>&nbsp;* Using attribute/value pairs, where attribute names are drawn from a controlled vocabulary.</span> </td>
                      </tr><tr>
                        <th> </th><th>20</th><td class="r"><span>&nbsp; * Pros: allows for an unlimited number of metadata elements, and easy representation of new elements as necessitated by new research approaches. The semantics of a metadata element can be as richly represented as desired, in a readily machine-readable form, by relating the attribute term to other ontology terms. The metadata representation is readily amenable to an OWL or RDF representation.</span> </td>
                      </tr><tr>
                        <th> </th><th>21</th><td class="r"><span>&nbsp; * Cons: a client cannot know in advance which metadata elements it may encounter (though it may limit itself to only interpret a pre-defined number of them), and the full semantics of a metadata element may change solely by the underlying ontology changing.</span> </td>
                      </tr><tr>
                        <th> </th><th>22</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>23</th><td class="r"><span>We feel that only using attribute/value pairs fits our and research requirements.</span> </td>
                      </tr><tr>
                        <th> </th><th>24</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>25</th><td class="r"><span>=== Operational Taxonomic Unit ===</span> </td>
                      </tr><tr>
                        <th> </th><th>26</th><td class="r"><span>The OTU perspective is an important use-case:</span> </td>
                      </tr><tr>
                        <th> </th><th>27</th><td class="r"><span>&nbsp; * Species tree hypothesis testing: splitting a given set of trees into subsets of trees as a function of compatibility to a given (set of) species tree(s). Degree of compatibility can be expressed as minimal sum of duplications needed to reconcile the gene with a species tree. I.e. measurement of the percentage of gene trees supporting an ecdysozoan versus a coelomata hypothesis.</span> </td>
                      </tr><tr>
                        <th> </th><th>28</th><td class="r"><span>&nbsp; &nbsp;* Problem: the query topology will be given with either gene name labels, or species name labels, but the labels of the trees will be OTUs.</span> </td>
                      </tr><tr>
                        <th> </th><th>29</th><td class="r"><span>&nbsp; &nbsp;* Hence, each OTU needs to be linked to the gene name(s) and taxon names, and it needs to be possible to specify that matching tree nodes use the linked taxon or gene names.</span> </td>
                      </tr><tr>
                        <th> </th><th>30</th><td class="r"><span>&nbsp; * The analysis mentioned above could be extended by asking questions about the (majority of) functional categories supporting a given species tree. These examples require association of the following data with gene tree nodes: taxonomy identifier, sequence identifier (which then, ideally, allows to retrieve functional data, such as GO).</span> </td>
                      </tr><tr>
                        <th> </th><th>31</th><td class="r"><span>&nbsp; * Gene tree analysis: similar to the Zmasek et al (2007) paper, one may want to build alignments and phylogenetic trees for all members of each protein&nbsp; (family) of a biological network (e.g. apoptsis). After loading the trees into a database, one could then query the database for those gene trees that exhibit a given pattern (e.g. lineage specific gene expansion or gene loss).</span> </td>
                      </tr><tr>
                        <th> </th><th>32</th><td class="r"><span>&nbsp; * In molecular and comparative genomics applications, one may want to find all trees that have been built for a certain sequence.</span> </td>
                      </tr><tr>
                        <th> </th><th>33</th><td class="r"><span>&nbsp; &nbsp;* Problem: As above, querying by sequence will give the gene name or the sequence accession number to match by, but tree nodes will have OTUs as labels. </span> </td>
                      </tr><tr>
                        <th> </th><th>34</th><td class="r"><span>&nbsp;* We discussed whether we need identifiers for OTUs.</span> </td>
                      </tr><tr>
                        <th> </th><th>35</th><td class="r"><span>&nbsp; * Pros: Rather than many individual idiosyncratic schemes for encoding sequence ID and taxon (and possibly additional information) into an OTU label, a single identifier could be resolved to the metadata using a common mechanism (such as LSID). Alternatively, one could standardize on a common encoding mechanism, that could then be parsed by a common mechanism.</span> </td>
                      </tr><tr>
                        <th> </th><th>36</th><td class="r"><span>&nbsp; * Cons: If using an (presumably opaque) identifier for OTUs, one ought to be able to expect that the same combination of sequence ID, taxon name (where one often implies the other, unless sequence ID is really an ambiguous gene name), and additional metadata (such as allele, population sample, etc) results in the same identifier, in essence necessitating an OTU identifier registry, or a common algorithm for constructing the identifier (which would then no longer be opaque). A standardized encoding mechanism would need to be widely supported and adopted.</span> </td>
                      </tr><tr>
                        <th> </th><th>37</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>38</th><td class="r"><span>----</span> </td>
                      </tr><tr>
                        <th> </th><th>39</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>40</th><td class="r"><span>== Formalizing scope, use cases, requirements (Tuesday) ==</span> </td>
                      </tr><tr>
                        <th> </th><th>41</th><td class="r"><span>In a [http://hackathon.dbcls.jp/attachment/wiki/PhyloWS_workgroup/P1070128.JPG white board] exercise the next day, we identified plausible input and output data types for phyloinformatic webservices. Plausibility is defined by our being able to imagine [https://www.nescent.org/wg_evoinfo/PhyloWS#Use_Cases use cases] (no time line for implementation implied, the goal here is to come up with interfaces)</span> </td>
                      </tr><tr>
                        <th> </th><th>42</th><td class="r"><span>&nbsp;* '''Inputs''' - The input data types defined here do not imply pass-by-value, i.e. "One Tree" could be some kind of identifier. In addition, it looks like several services need multiple data types (e.g. a matrix + a tree, in order to return a tree score). Given that accumulate-and-fire (i.e. stateful operations, where you first post a matrix, then a tree) is a Bad Thing, and that tunneling multiple data types in a single attachment or body (e.g. a chunk of nexus/nexml) is also a Bad Thing, it seems that these combinations of data would be submitted as multiple post parameters.</span> </td>
                      </tr><tr>
                        <th> </th><th>43</th><td class="r"><span>&nbsp; * '''One Tree''' - exactly one tree, which might function as a query topology, as an input for topology metric calculations, or as something for which associated data (matrices) and metadata might be retrieved</span> </td>
                      </tr><tr>
                        <th> </th><th>44</th><td class="r"><span>&nbsp; * '''Pair of Trees''' - exactly two trees, which function as inputs for tree reconciliation (e.g. duplication inference) or for tree-to-tree distance calculations</span> </td>
                      </tr><tr>
                        <th> </th><th>45</th><td class="r"><span>&nbsp; * '''Set of Trees''' - input for consensus calculations, or as query topologies</span> </td>
                      </tr><tr>
                        <th> </th><th>46</th><td class="r"><span>&nbsp; * '''One OTU''' - exactly one OTU for which associated data (trees or matrices that contain it) and metadata might be retrieved</span> </td>
                      </tr><tr>
                        <th> </th><th>47</th><td class="r"><span>&nbsp; * '''Pair of OTUs''' - exactly two OTUs, as input for topological queries (MRCA) and calculations (patristic distance)</span> </td>
                      </tr><tr>
                        <th> </th><th>48</th><td class="r"><span>&nbsp; * '''Set of OTUs''' - input for topological queries (MRCA) and for which data (trees or matrices that contain them) and metadata might be retrieved</span> </td>
                      </tr><tr>
                        <th> </th><th>49</th><td class="r"><span>&nbsp; * '''One Node''' - input for tree traversal operations (parent, children) and for which metadata might be retrieved</span> </td>
                      </tr><tr>
                        <th> </th><th>50</th><td class="r"><span>&nbsp; * '''Pair of Nodes''' - input for topological queries (MRCA) and calculations (patristic distance)</span> </td>
                      </tr><tr>
                        <th> </th><th>51</th><td class="r"><span>&nbsp; * '''Set of Nodes''' - input for topological queries (MRCA)</span> </td>
                      </tr><tr>
                        <th> </th><th>52</th><td class="r"><span>&nbsp; * '''One Character''' - exactly one character (matrix column) for which calculations are performed (variability) and metadata is retrieved</span> </td>
                      </tr><tr>
                        <th> </th><th>53</th><td class="r"><span>&nbsp; * '''Set of Characters''' - input as filter predicate, to retrieve OTUs that contain recorded states for the characters</span> </td>
                      </tr><tr>
                        <th> </th><th>54</th><td class="r"><span>&nbsp; * '''One Character State Sequence''' - for which metadata is retrieved</span> </td>
                      </tr><tr>
                        <th> </th><th>55</th><td class="r"><span>&nbsp; * '''Pair of Character State Sequences''' - as input for pairwise alignments, as input to calculate pairwise divergence</span> </td>
                      </tr><tr>
                        <th> </th><th>56</th><td class="r"><span>&nbsp; * '''Set of Character State Sequences''' - as input for multiple sequence alignment</span> </td>
                      </tr><tr>
                        <th> </th><th>57</th><td class="r"><span>&nbsp; * '''Character State Matrix''' - as input for inference (of one tree or set of trees), as input for calculations (average sequence divergence) and for which metadata is retrieved</span> </td>
                      </tr><tr>
                        <th> </th><th>58</th><td class="r"><span></span> </td>
                      </tr><tr>
                        <th> </th><th>59</th><td class="r"><span>&nbsp;* '''Outputs''' - In addition to the mirroring the inputs described above, some 'primitives' may be required:</span> </td>
                      </tr><tr>
                        <th> </th><th>60</th><td class="r"><span>&nbsp; * '''Int''' - an integer, for things such as topology metrics (node counts) tree-to-tree distances (in branch moves) node distances (in number of nodes in between), character state counts, sequence divergence (substitution counts, site counts)</span> </td>
                      </tr><tr>
                        <th> </th><th>61</th><td class="r"><span>&nbsp; * '''Float''' - a floating point value, for topology metrics (balance, stemminess, resolution) tree-to-tree distances (symmetric difference), patristic distance, sequence divergence</span> </td>
                      </tr><tr>
                        <th> </th><th>62</th><td class="r"><span>&nbsp; * '''String''' - for metadata, e.g. descriptions</span> </td>
                      </tr><tr>
                        <th> </th><th>63</th><td class="r"><span>&nbsp; * '''Stringvector''' - for metadata, e.g. a set of tags</span> </td>
                      </tr><tr>
                        <th> </th><th>64</th><td class="r"><span>&nbsp; * For all I/O combinations, imagine a [https://www.nescent.org/wg/evoinfo/index.php?title=PhyloWS#Use_Cases use case], move to NESCent wiki</span> </td>
                      </tr><tr class="last">
                        <th> </th><th>65</th><td class="r"><span>&nbsp; * For each use case, classify [https://www.nescent.org/wg/evoinfo/index.php?title=PhyloWS#PhyloWS_Requirements scope and requirements]</span> </td>
                      </tr>
            </tbody><tbody class="unmod">
                  <tr>
                          <th>14</th><th>66</th><td class="l"><span>=== Scopes ===</span> </td>
                  </tr><tr>
                          <th>15</th><th>67</th><td class="l"><span>We identified three main scopes of interest to implement:</span> </td>
                  </tr>
            </tbody>
              <tbody class="skipped">
                <tr>
                  <th><a href="PhyloWS_workgroup@version=50.html#L17">…</a></th>
                  <th><a href="PhyloWS_workgroup@version=51.html#L69">…</a></th>
                  <td> </td>
                </tr>
              </tbody>
            <tbody class="unmod">
                  <tr>
                          <th>17</th><th>69</th><td class="l"><span>&nbsp;* '''Phylogenetic data conversion''', i.e. make sure that inputs and outputs of data work syntactically</span> </td>
                  </tr><tr>
                          <th>18</th><th>70</th><td class="l"><span>&nbsp;* '''Phylogenetic data analysis''', i.e. actual computations</span> </td>
                  </tr>
            </tbody><tbody class="mod">
                      <tr class="first">
                        <th>19</th><th> </th><td class="l"><span>=== API design ===</span> </td>
                      </tr>
                      <tr>
                        <th> </th><th>71</th><td class="r"><span>----</span> </td>
                      </tr><tr class="last">
                        <th> </th><th>72</th><td class="r"><span>== API design ==</span> </td>
                      </tr>
            </tbody><tbody class="unmod">
                  <tr>
                          <th>20</th><th>73</th><td class="l"><span>''Assuming that syntax and semantics of the data can be solved, what would be the syntax and semantics of making the connections?''</span> </td>
                  </tr><tr>
                          <th>21</th><th>74</th><td class="l"><span>=== API design principles ===</span> </td>
                  </tr>
            </tbody>
              <tbody class="skipped">
                <tr>
                  <th><a href="PhyloWS_workgroup@version=50.html#L38">…</a></th>
                  <th><a href="PhyloWS_workgroup@version=51.html#L91">…</a></th>
                  <td> </td>
                </tr>
              </tbody>
            <tbody class="unmod">
                  <tr>
                          <th>38</th><th>91</th><td class="l"><span></span> </td>
                  </tr><tr>
                          <th>39</th><th>92</th><td class="l"><span></span> </td>
                  </tr>
            </tbody><tbody class="rem">
                  <tr class="first">
                          <th>40</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>41</th><th> </th><td class="l"><del>----</del> </td>
                  </tr><tr>
                          <th>42</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>43</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>44</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>45</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>46</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>47</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>48</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>49</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>50</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>51</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>52</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>53</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>54</th><th> </th><td class="l"><del>Here are several ideas for tasks we can work on at the hackathon:</del> </td>
                  </tr><tr>
                          <th>55</th><th> </th><td class="l"><del>&nbsp;* Defining scope </del> </td>
                  </tr><tr>
                          <th>56</th><th> </th><td class="l"><del>&nbsp;* Issue of identifiers and OTUs</del> </td>
                  </tr><tr>
                          <th>57</th><th> </th><td class="l"><del>&nbsp;* Accumulating [https://www.nescent.org/wg_evoinfo/PhyloWS#Use_Cases use-cases]</del> </td>
                  </tr><tr>
                          <th>58</th><th> </th><td class="l"><del>&nbsp;* Formulating a task-oriented API [https://www.nescent.org/wg_evoinfo/PhyloWS#PhyloWS_Requirements requirements] description</del> </td>
                  </tr><tr>
                          <th>59</th><th> </th><td class="l"><del>&nbsp;* Proposing a concrete REST~~ or SOAP-~~based API</del> </td>
                  </tr><tr>
                          <th>60</th><th> </th><td class="l"><del>&nbsp;* Propose input/output formats (e.g. http://$resource?view=$format where $resource is an opaque url to some data resource (matrix, tree, etc) and $format something like nexus, phylip, nexml, phyloxml, json, etc.)</del> </td>
                  </tr><tr>
                          <th>61</th><th> </th><td class="l"><del>&nbsp;* Start a reference implementation, for example based on data in BioSQL</del> </td>
                  </tr><tr>
                          <th>62</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>63</th><th> </th><td class="l"><del>Gathering of use-cases and task-oriented requirements has started at http://evoinfo.nescent.org/PhyloWS.</del> </td>
                  </tr><tr>
                          <th>64</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>65</th><th> </th><td class="l"><del>[[PageOutline(1-3)]]</del> </td>
                  </tr><tr>
                          <th>66</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>67</th><th> </th><td class="l"><del>== Open Space discussion ==</del> </td>
                  </tr><tr>
                          <th>68</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>69</th><th> </th><td class="l"><del>The Open Space discussion centered on the following issues:</del> </td>
                  </tr><tr>
                          <th>70</th><th> </th><td class="l"><del>&nbsp;* The OTU (Operational Taxonomic Unit) perspective is an important use-case. </del> </td>
                  </tr><tr>
                          <th>71</th><th> </th><td class="l"><del>&nbsp; * Species tree hypothesis testing: splitting a given set of trees into subsets of trees as a function of compatibility to a given (set of) species tree(s). Degree of compatibility can be expressed as minimal sum of duplications needed to reconcile the gene with a species tree. I.e. measurement of the percentage of gene trees supporting an ecdysozoan versus a coelomata hypothesis.</del> </td>
                  </tr><tr>
                          <th>72</th><th> </th><td class="l"><del>&nbsp; &nbsp;* Problem: the query topology will be given with either gene name labels, or species name labels, but the labels of the trees will be OTUs.</del> </td>
                  </tr><tr>
                          <th>73</th><th> </th><td class="l"><del>&nbsp; &nbsp;* Hence, each OTU needs to be linked to the gene name(s) and taxon names, and it needs to be possible to specify that matching tree nodes use the linked taxon or gene names.</del> </td>
                  </tr><tr>
                          <th>74</th><th> </th><td class="l"><del>&nbsp; * The analysis mentioned above could be extended by asking questions about the (majority of) functional categories supporting a given species tree. These examples require association of the following data with gene tree nodes: taxonomy identifier, sequence identifier (which then, ideally, allows to retrieve functional data, such as GO).</del> </td>
                  </tr><tr>
                          <th>75</th><th> </th><td class="l"><del>&nbsp; * Gene tree analysis: similar to the Zmasek et al (2007) paper, one may want to build alignments and phylogenetic trees for all members of each protein&nbsp; (family) of a biological network (e.g. apoptsis). After loading the trees into a database, one could then query the database for those gene trees that exhibit a given pattern (e.g. lineage specific gene expansion or gene loss).</del> </td>
                  </tr><tr>
                          <th>76</th><th> </th><td class="l"><del>&nbsp; * In molecular and comparative genomics applications, one may want to find all trees that have been built for a certain sequence.</del> </td>
                  </tr><tr>
                          <th>77</th><th> </th><td class="l"><del>&nbsp; &nbsp;* Problem: As above, querying by sequence will give the gene name or the sequence accession number to match by, but tree nodes will have OTUs as labels. </del> </td>
                  </tr><tr>
                          <th>78</th><th> </th><td class="l"><del>&nbsp;* We discussed whether we need identifiers for OTUs.</del> </td>
                  </tr><tr>
                          <th>79</th><th> </th><td class="l"><del>&nbsp; * Pros: Rather than many individual idiosyncratic schemes for encoding sequence ID and taxon (and possibly additional information) into an OTU label, a single identifier could be resolved to the metadata using a common mechanism (such as LSID). Alternatively, one could standardize on a common encoding mechanism, that could then be parsed by a common mechanism.</del> </td>
                  </tr><tr>
                          <th>80</th><th> </th><td class="l"><del>&nbsp; * Cons: If using an (presumably opaque) identifier for OTUs, one ought to be able to expect that the same combination of sequence ID, taxon name (where one often implies the other, unless sequence ID is really an ambiguous gene name), and additional metadata (such as allele, population sample, etc) results in the same identifier, in essence necessitating an OTU identifier registry, or a common algorithm for constructing the identifier (which would then no longer be opaque). A standardized encoding mechanism would need to be widely supported and adopted.</del> </td>
                  </tr><tr>
                          <th>81</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>82</th><th> </th><td class="l"><del>&nbsp;* We also need to be able to ossociate (typed) data with tree branches</del> </td>
                  </tr><tr>
                          <th>83</th><th> </th><td class="l"><del>&nbsp; * The obvious example are branch lengths</del> </td>
                  </tr><tr>
                          <th>84</th><th> </th><td class="l"><del>&nbsp; * But we usually also have (possibly multiple) support values associated with tree branches</del> </td>
                  </tr><tr>
                          <th>85</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>86</th><th> </th><td class="l"><del>=== Inputs ===</del> </td>
                  </tr><tr>
                          <th>87</th><th> </th><td class="l"><del>The input data types defined here do not imply pass-by-value, i.e. "One Tree" could be some kind of identifier. In addition, it looks like several services need multiple data types (e.g. a matrix + a tree, in order to return a tree score). Given that accumulate-and-fire (i.e. stateful operations, where you first post a matrix, then a tree) is a Bad Thing, and that tunneling multiple data types in a single attachment or body (e.g. a chunk of nexus/nexml) is also a Bad Thing, it seems that these combinations of data would be submitted as multiple post parameters.</del> </td>
                  </tr><tr>
                          <th>88</th><th> </th><td class="l"><del>&nbsp;* '''One Tree''' - exactly one tree, which might function as a query topology, as an input for topology metric calculations, or as something for which associated data (matrices) and metadata might be retrieved</del> </td>
                  </tr><tr>
                          <th>89</th><th> </th><td class="l"><del>&nbsp;* '''Pair of Trees''' - exactly two trees, which function as inputs for tree reconciliation (e.g. duplication inference) or for tree-to-tree distance calculations</del> </td>
                  </tr><tr>
                          <th>90</th><th> </th><td class="l"><del>&nbsp;* '''Set of Trees''' - input for consensus calculations, or as query topologies</del> </td>
                  </tr><tr>
                          <th>91</th><th> </th><td class="l"><del>&nbsp;* '''One OTU''' - exactly one OTU for which associated data (trees or matrices that contain it) and metadata might be retrieved</del> </td>
                  </tr><tr>
                          <th>92</th><th> </th><td class="l"><del>&nbsp;* '''Pair of OTUs''' - exactly two OTUs, as input for topological queries (MRCA) and calculations (patristic distance)</del> </td>
                  </tr><tr>
                          <th>93</th><th> </th><td class="l"><del>&nbsp;* '''Set of OTUs''' - input for topological queries (MRCA) and for which data (trees or matrices that contain them) and metadata might be retrieved</del> </td>
                  </tr><tr>
                          <th>94</th><th> </th><td class="l"><del>&nbsp;* '''One Node''' - input for tree traversal operations (parent, children) and for which metadata might be retrieved</del> </td>
                  </tr><tr>
                          <th>95</th><th> </th><td class="l"><del>&nbsp;* '''Pair of Nodes''' - input for topological queries (MRCA) and calculations (patristic distance)</del> </td>
                  </tr><tr>
                          <th>96</th><th> </th><td class="l"><del>&nbsp;* '''Set of Nodes''' - input for topological queries (MRCA)</del> </td>
                  </tr><tr>
                          <th>97</th><th> </th><td class="l"><del>&nbsp;* '''One Character''' - exactly one character (matrix column) for which calculations are performed (variability) and metadata is retrieved</del> </td>
                  </tr><tr>
                          <th>98</th><th> </th><td class="l"><del>&nbsp;* '''Set of Characters''' - input as filter predicate, to retrieve OTUs that contain recorded states for the characters</del> </td>
                  </tr><tr>
                          <th>99</th><th> </th><td class="l"><del>&nbsp;* '''One Character State Sequence''' - for which metadata is retrieved</del> </td>
                  </tr><tr>
                          <th>100</th><th> </th><td class="l"><del>&nbsp;* '''Pair of Character State Sequences''' - as input for pairwise alignments, as input to calculate pairwise divergence</del> </td>
                  </tr><tr>
                          <th>101</th><th> </th><td class="l"><del>&nbsp;* '''Set of Character State Sequences''' - as input for multiple sequence alignment</del> </td>
                  </tr><tr>
                          <th>102</th><th> </th><td class="l"><del>&nbsp;* '''Character State Matrix''' - as input for inference (of one tree or set of trees), as input for calculations (average sequence divergence) and for which metadata is retrieved</del> </td>
                  </tr><tr>
                          <th>103</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>104</th><th> </th><td class="l"><del>=== Outputs ===</del> </td>
                  </tr><tr>
                          <th>105</th><th> </th><td class="l"><del>In addition to the mirroring the inputs described above, some 'primitives' may be required:</del> </td>
                  </tr><tr>
                          <th>106</th><th> </th><td class="l"><del>&nbsp;* '''Int''' - an integer, for things such as topology metrics (node counts) tree-to-tree distances (in branch moves) node distances (in number of nodes in between), character state counts, sequence divergence (substitution counts, site counts)</del> </td>
                  </tr><tr>
                          <th>107</th><th> </th><td class="l"><del>&nbsp;* '''Float''' - a floating point value, for topology metrics (balance, stemminess, resolution) tree-to-tree distances (symmetric difference), patristic distance, sequence divergence</del> </td>
                  </tr><tr>
                          <th>108</th><th> </th><td class="l"><del>&nbsp;* '''String''' - for metadata, e.g. descriptions</del> </td>
                  </tr><tr>
                          <th>109</th><th> </th><td class="l"><del>&nbsp;* '''Stringvector''' - for metadata, e.g. a set of tags</del> </td>
                  </tr><tr>
                          <th>110</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>111</th><th> </th><td class="l"><del>== Node metadata ==</del> </td>
                  </tr><tr>
                          <th>112</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>113</th><th> </th><td class="l"><del>There is an extensive number of metadata elements one might want to record for nodes in a tree. Beyond the basic gene name, sequence ID, and taxon, metadata range from biogeography (area, lat/long), to host species (for analyses of host/parasite co-evolution), to functional attributes (GO terms, expression, subcellular location). </del> </td>
                  </tr><tr>
                          <th>114</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>115</th><th> </th><td class="l"><del>Some of these attributes may blur the line to actual character data for nodes (whether tips or internal). In fact, the notion of strictly distinguishing between node metadata and node character data may not be tenable or useful in reality; data may be metadata in one situation, and used as correlated character in another situation, and used for tree inference in a third situation.</del> </td>
                  </tr><tr>
                          <th>116</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr>
                          <th>117</th><th> </th><td class="l"><del>There are essentially two ways to represent node metadata:</del> </td>
                  </tr><tr>
                          <th>118</th><th> </th><td class="l"><del>&nbsp;* Using a metadata schema (for example, an XML Schema, or a XML document definition, similar to metadata schemas in use in the library sciences such as DC, MARC21, etc).</del> </td>
                  </tr><tr>
                          <th>119</th><th> </th><td class="l"><del>&nbsp; * Pros: provides a clear expectation for clients as to what metadata to expect, and the meaning of those elements can be (hard-) coded into applications.</del> </td>
                  </tr><tr>
                          <th>120</th><th> </th><td class="l"><del>&nbsp; * Cons: limited to whatever the metadata schema allows for, and any new metadata elements deemed useful by emerging research cannot be readily expressed (and rectifying that requires a metadata schema update, which in turn affects client applications rather directly). In addition, the meaning of metadata elements cannot be dynamically inferred or stated; it is implicit from the XML DTD or Schema definition.</del> </td>
                  </tr><tr>
                          <th>121</th><th> </th><td class="l"><del>&nbsp;* Using attribute/value pairs, where attribute names are drawn from a controlled vocabulary.</del> </td>
                  </tr><tr>
                          <th>122</th><th> </th><td class="l"><del>&nbsp; * Pros: allows for an unlimited number of metadata elements, and easy representation of new elements as necessitated by new research approaches. The semantics of a metadata element can be as richly represented as desired, in a readily machine-readable form, by relating the attribute term to other ontology terms. The metadata representation is readily amenable to an OWL or RDF representation.</del> </td>
                  </tr><tr>
                          <th>123</th><th> </th><td class="l"><del>&nbsp; * Cons: a client cannot know in advance which metadata elements it may encounter (though it may limit itself to only interpret a pre-defined number of them), and the full semantics of a metadata element may change solely by the underlying ontology changing.</del> </td>
                  </tr><tr>
                          <th>124</th><th> </th><td class="l"><del></del> </td>
                  </tr><tr class="last">
                          <th>125</th><th> </th><td class="l"><del>We feel that only using attribute/value pairs fits our and research requirements.</del> </td>
                  </tr>
            </tbody>
        </table>
      </li>
  </ul>
</div>
      </div>
  </div>
    </div>
    <div id="footer" lang="en" xml:lang="en"><hr />
      <a id="tracpowered" href="http://trac.edgewall.org/"><img src="../chrome/common/trac_logo_mini.png" height="30" width="107" alt="Trac Powered" /></a>
      <p class="left">
        Powered by <a href="../about.html"><strong>Trac 0.11.6</strong></a><br />
        By <a href="http://www.edgewall.org/">Edgewall Software</a>.
      </p>
      <p class="right">Visit the Trac open source project at<br /><a href="http://trac.edgewall.org/">http://trac.edgewall.org/</a></p>
    </div>
  </body>
</html>
